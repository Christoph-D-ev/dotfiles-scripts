	\chapter{Einleitung}
	
	Der Fokus dieser Arbeit ist die Implementation des  in {\it Approximation LZ77 via Small-Space Multiple-Pattern Matching}  beschriebenen Algorithmus zur Approximierung der \\ \textit{LZ77-Faktorisierung} \cite{LZ77Approx}.
	Für einen Eingabewert \textit{T} wird erwartet, dass \textit{T} in nicht mehr als doppelt so viele Faktoren zerlegt wird als von einer optimalen \textit{LZ77-Faktorisierung}.
	Dabei soll die Laufzeit der Implementation sich an die Laufzeit der im \textit{tudocomp} vorhandenen Implementation von \textit{LZ77} orientieren. 
	%
	%
	%
	%
	\section{Motivation und Relevanz}
	
	Kompression ist ein zentraler Bestandteil  moderner Computersysteme. Das Komprimieren von Dateien spart Speicherplatz und dadurch Hardwarekosten.
	An Videodaten ist dies besonders deutlich zu erkennen. Eine Sekunde unkomprimiertes Videomaterial in einer üblichen Auflösung von 1920 x 1080 mit Standard 60 \textit{frames-per-second} und einer Farbtiefe von 24-Bit belegt alleine 2.98GB.
	Komprimiert mit dem \textit{H.264}-Standard belegen die gleichen Informationen nur 0.01GB Speicherplatz \cite{h.264}.\\
	%
	%
	%
	Ein weiterer wichtiger Anwendungsfall für die Kompression ist die Übertragung von Daten.
	Zugänge zu Netzwerken sind meist in ihrer Geschwindigkeit oder in ihrem Datenvolumen begrenzt. Die Möglichkeit Daten vor dem Übertragen zu komprimieren erhöht damit die Menge an Informationen, die wir über ein Netzwerk übertragen können.
	Für mobile Geräte und Streamingdienste ist dies von enormer Bedeutung. \\
	%
	%
	%
	%
	\textit{IoT}-Geräte wie \textit{smartsensors} und \textit{embedded systems} produzieren Daten und senden diese über ein Netzwerk. Um die Auslastung des Netzwerkes zu verringern ist es sinnvoll, dass bereits diese ihre Daten komprimieren \cite{7149287} \cite{IoT2}. Diese Geräte sind aber oft in Rechenleistung und Speicher begrenzt, um dennoch eine Kompression ausführen zu können, braucht man spezielle Kompressionsalgorithmen die dies berücksichtigen.\\
	%
	%
	%
	%
	%
	{\it LZ77} ist ein verlustfreier Kompressionsalgorithmus mit weitem Einsatzgebiet.
	{\it LZ77} eliminiert sich wiederholende Zeichenketten und ersetzt diese durch Verweise auf identische vorherige Ketten.
	Die so entstandene Struktur aus Verweisen und Zeichenketten ermöglicht es die gleichen Daten komprimiert darzustellen \cite{LZ77}.\\
	%
	%
	%
	Trotz seines Alters von mehr als 40 Jahren ist \textit{LZ77} die Grundlage für eine ganze Familie an klassischen und modernen Kompressionsverfahren \cite{LZSS} \cite{brotli} \cite{geldreich}.
	So basieren zum Beispiel die bekannten Formate \textit{.png},  \textit{.zip} darauf, \textit{LZ77} als Teilschritt anwenden zu können \cite{PNG} \cite{deflate}. Die effiziente Berechnung der {\it LZ77-Faktorisierung} ist daher von großer Bedeutung.\\
	%
	%
	%
	%
	Es existiert  eine Vielzahl an Möglichkeiten eine {\it LZ77-Faktorisierung} zu generieren.
	Bekannte Ansätze sind, die Eingabe in \textit{chunks} aufzuteilen, ein \textit{sliding-window} zu benutzen, der Einsatz von \textit{suffix-trees} oder Graphentheorie \cite{deflate} \cite{LZ77parrallel} \cite{shun} \cite{Nittograph}.
	Des weiteren existieren Designs für parallele und verteile Algorithmen \cite{distribut} und Konzepte die besonders sparsam mit Ressourcen umgehen \cite{karker}.\\
	%
	%
	%
	%
	Der in {\it Approximation LZ77 via Small-Space Multiple-Pattern Matching} vorgestellte Algorithmus ist besonders sparsam im Hinblick auf den zur Laufzeit benötigten Speicher \cite{LZ77Approx}. Da der Speicher zur Laufzeit ein allgemeiner Flaschenhals heutiger Systeme darstellt, ist eine Approximation hier sinnvoll, um bei limitierten Ressourcen ein bestmögliches Ergebnis zu erzielen \cite{LZ77Approx}.
	
	\section{Ziele und Arbeitsverlauf}
	
	Das Ziel dieser Arbeit ist die Implementation und experimentelle Evaluation des in {\it Approximation LZ77 via Small-Space Multiple-Pattern Matching} beschriebenen Algorithmus. Für einen Eingabewert \textit{T} wird erwartet, dass \textit{T} in nicht mehr als doppelt so viele Faktoren zerlegt wird als von einer optimalen \textit{LZ77-Faktorisierung}. Die erarbeitete Implementation soll in das {\it TU Dortmund Compression Framework} integriert werden.\\
	%%
	%%
	%%
	Der erste Schritt dazu ist die Transformation des theoretisch beschriebenen Algorithmus in eine praktische und umsetzbare Variante. Bereits bekannte Teilprobleme sollen erkannt werden und entsprechenden bestehenden Bibliotheken zugeordnet werden.
	Ein allgemeiner Entwurf des Programms und dessen Arbeitsweise wird in dieser Phase erarbeitet.
	Besondere Beachtung wird dem effizienten Umgang mit dem benötigten Speicher gewidmet, da dies ein häufiges Problem in heutigen Anwendungen darstellt.\\
	%%
	%%
	Als zweiter Schritt folgt eine Implementation des erarbeiteten Entwurfs. Die Implementation erfolgt \textit{testdriven} in \textit{C++} und beachtet den \textit{Google C++ Style Guide} \cite{styleguide}. Die Implementation soll generisch genug sein um gewählte Parameter wie bspw. die gewählte Hashfunktion, die Fenstergröße oder die Minimalgröße eines Verweises problemlos verändern zu können.
	Diese Phase endet wenn die Implementation konstant korrekte Ergebnisse produziert.\\
	%%
	%%
	Der dritte Schritt ist es das entstandene Programm zu verbessern. Dies wird erreicht indem das Programm experimentell getestet wird. Anhand der Ergebnisse dieser Experimente sollen Modelle und der Code selber angepasst werden. Die daraus entstandene Version wird erneut getestet und angepasst. Besondere Beachtung soll dem effizienten Umgang mit dem benötigten Speicher zukommen. Im allgemeinen soll der Arbeitsverlauf die als \textit{Algorithm Engineering} bekannten Methoden widerspiegeln \cite{Algoengeieer}.\\
	%%
	%%
	%%
	Nach den Implementationsphasen erfolgt eine experimentelle Datenerhebung. Zunächst werden Testumgebung und als Eingabe dienende Datensätze gewählt. Darauf erfolgen Tests über alle Datensätze für verschiedenste Kombinationen an Parametern hinsichtlich Laufzeit, Speicher und Kompressionsgrad.
	Als Vergleichswerte werden ebenfalls Daten zu den im {\it TU Dortmund Compression Framework} vorhandenen Algorithmen erhoben.\\
	%%
	%%
	%%
	Eine statistische Aufarbeitung, Auswertung und Visualisierung der Daten bildet den Abschluss der Arbeit. Die verschiedenen Versionen sollen miteinander verglichen und bewertet werden.\\
	%%
	%%
	Optionale Ziele sind die weitere Verbesserung der Laufzeit und des Speicherbedarfs der Implementation.
	Des weiteren könnte eine zweite Datenerhebung stattfinden, die kleinere Systeme wie Smartphones oder \textit{raspberry pi} in den Fokus rückt. 

