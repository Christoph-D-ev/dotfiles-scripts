\chapter{Grundlagen }


Im Folgenden werden Grundbegriffe und Zusammenhänge der Kompression, Approximation und insbesondere der LZ-Zerlegung erläutert.

\section{Kompression}

\emph{Kompression} ist die Transformation von Daten in eine kleinere Menge an Daten.
Es gibt zwei Möglichkeiten, diese Transformation auszuführen, verlustfrei oder verlustbehaftet.
Alle verlustfreien Ansätze basieren darauf, Redundanzen innerhalb eines Datensatzes zu eliminieren, während verlustbehaftete Methoden ausgewählte Daten löschen.
Der bedeutende Unterschied zwischen diesen beiden Ansätzen ist, dass sich nur aus einer verlustfreien Kompression das Original wiederherstellen lässt.\\
Die Güte einer Kompression, der \emph{Kompressionsgrad}, ist definiert als:
\begin{equation}
\text{Kompressionsgrad} =\frac{\text{Gr"o\ss e der Ausgabe}}{\text{Gr"o\ss e der Eingabe}}
\end{equation}
Während der \emph{Kompressionsfaktor} das Inverse des Kompressionsgrades ist:
\begin{equation}
\text{Kompressionsfaktor} =\frac{\text{Gr"o\ss e der Eingabe}}{\text{Gr"o\ss e der Ausgabe}}
\end{equation}
Keine verlustfreie Kompressionsmethode kann einen Kompressionsgrad $<1$ garantieren, ein Kompressionsgrad ist immer von der Eingabe abhängig. Sollte theoretisch eine solche Methode existieren, könnte man sie immer wieder auf ihre eigenen Ausgaben anwenden und jegliche Datenmenge in nur einem einzelnen Bit codieren, was offensichtlich unmöglich ist \cite{compressreff}.\\
Im Folgenden beschäftige ich mich ausschließlich mit verlustfreien Verfahren, der Begriff der Kompression bezieht sich deshalb immer auf die verlustfreie Kompression.

\newpage
\section{String}
Eine fundamentale Art Informationen darzustellen ist der \emph{String}.
Ein \emph{String} $s$ der Länge $n$ ist eine
Folge von Symbolen $s[1],s[2],\cdots ,s[n-1]$ aus einem Alphabet $\Sigma$.
\\
Der String \textit{u} ist ein \emph{Substring}  von \textit{w}, wenn 
gilt:
\begin{equation}
\exists i \in  \mathbb{N}.\bigwedge_{j=1}^{|u|} w[j+i]=u[j]
\end{equation}\\
Ein Substring  $u$ besitzt einen \emph{vorherigen Substring}, wenn für $u$ beginnend an Index $i$ gilt:
\begin{equation}
\exists k \in  \mathbb{N}. k<i  \land \bigwedge_{j=1}^{|u|} w[j+k]=u[j]
\end{equation}
Für Substrings  existieren zwei Kategorien von besonderer Bedeutung, Präfixe und Suffixe.
Präfixe sind Substrings  die an Index $1$ beginnen, während Suffixe Substrings  sind die an Index $n$ enden.
Als \emph{echte Substrings}  bezeichnet man Substrings  die kürzer sind als der String  in dem sie liegen.
Im Folgenden soll \emph{Substring}[$i,l$] den Substring  der an Index \textit{i} beginnt und an Index \textit{l} endet bezeichnen.\\
In \textit{C++} existieren zwei Konzepte die als String  bezeichnet werden, der \textit{C-style char array} und die \textit{std::string} Klasse.
Das \textit{C-style char array} ist ein kontinuierlicher Block an Speicher mit fester Größe. In diesem Block liegen \textit{chars}, die Symbole darstellen, direkt hintereinander. Die Größe des \textit{arrays} kann nachträglich nicht verändert werden.\\
Die \textit{std::string} Klasse spezifiziert Objekte, die ein \textit{char array} enthalten. Objekte der Klasse String  bieten weitere Funktionalitäten und die Möglichkeit, die Länge des Strings  zu verändern \cite{cplusplus}.
\newpage
\section{LZ-Zerlegung}
Eine LZ-Zerlegung ist eine Aufteilung eines String \textit{T} in sich nicht überschneidende Substrings, diese Substrings  bezeichnet man als Faktoren.
Für jeden Faktor gilt, dass er  entweder ein Substring  ist zu dem ein vorheriger Substring  existiert oder der Faktor aus einem einzelnen Symbol besteht.
Des weiteren ist jeder Faktor maximal in seiner möglichen Länge.
Dass heißt für jeden Faktor $f[i,l]$, also jeden Substring$[i,l]$ in der LZ-Zerlegung $LZ()$ der Eingabe $T$ gilt:
\begin{align}
\nonumber
&\text{Die Faktoren überschneiden sich nicht:}\\
&\forall f_{x}[i_{x},l_{x}] \in LZ(T). \ i_{x}= l_{x-1} + 1 \lor ( x=1 \land i_{x}=1 )\\\nonumber
&\text{Die Faktoren sind einzelne Symbole oder besitzen vorherige Substrings:}\\
&\forall f_{x}[i_{x},l_{x}] \in LZ(T). \ l_{x} = i_{x}+1 \lor \exists k \in  \mathbb{N}. k<i  \land \bigwedge_{j=1}^{l-i} T[k+j]=T[i+j] \\\nonumber
&\text{Die Faktoren sind in ihrer möglichen Länge maximal:}\\ 
&\forall f_{x}[i_{x},l_{x}] \in LZ(T). \  \nexists k \in \mathbb{N}. \ {} k > l_{x} \land \exists j \in  \mathbb{N}. j < i  \land \bigwedge_{h=1}^{k} T[j+h]=T[i+h]
\end{align}
Die LZ-Zerlegung erlaubt es, einen String  komprimiert darzustellen.
Diese Kompression wird erreicht, indem in der LZ-Zerlegung Faktoren durch Referenzen ersetzt werden.
Jede Referenz ist ein Tupel aus zwei Zahlen, das  einen vorher liegenden Substring  identifiziert
Das erste Element des Tupels enthält Informationen über die Position des vorher liegenden Substrings, während das zweite Element die Länge des Substrings angibt.
Die Positionsangabe kann dabei ein \textit{offset} oder ein absoluter Index über den faktorisierten  String  sein.
Ein \textit{offset} findet häufiger Verwendung, da für größere Strings  ein absoluter Index $\lceil \log_2{n}\rceil$ Bits belegt, wobei $n = |Eingabe|$.\\
Allerdings werden nicht alle Substrings  durch Referenzen ersetzt.
Wenn die zugehörige Referenz mehr Speicher benötigt, als der Faktor selbst, lohnt es sich nicht den Substring  zu ersetzten.
Ebenfalls wird keine Referenz gespeichert, wenn der Faktor ein einzelnes Symbol ist \cite{LZ77}.
\newpage
\section{Approximation}

Zu jedem Optimierungsproblem existiert eine Menge an richtigen Lösungen und in dieser eine Teilmenge an optimalen Lösungen. 
Ein Approximationsalgorithmus erzeugt für eine Eingabe eine richtige Lösung, die aber nicht zwangsläufig optimal sein muss.\\
Die \emph{Approximationsgüte} $\rho$ ist eine Garantie, wie sehr die erzeugte Lösung \textit{s\textsubscript{e}} maximal von einer optimalen Lösung \textit{s\textsubscript{opt}} abweicht. Um komplexe Ergebnisse vergleichen zu können, evaluiert man beide durch eine Bewertungsfunktion \textit{f(x)} \cite{approxdef}.
\begin{equation}
\rho= maximum
\left\{
\frac{f(s_{e})}{f(s_{opt})},\frac{f(s_{opt})}{f(s_{e})}
\right\}
\end{equation}
Da eine Abweichung vom Optimum sowohl größer als auch kleiner als  \glqq 1\grqq{} sein kann ist der größere der beiden Brüche die Güte.

\section{LZ-Approximation}
Zu jedem beliebigen String  existiert eine LZ-Zerlegung. Eine Approximation dieser Zerlegung besteht, wenn die Faktoren in ihrer Länge nicht zwingend maximal sind. Die Faktoren der Approximation sind weiterhin entweder einzelne Symbole oder besitzen vorherige Substrings.\\
Eine \textit{c-optimale} \emph{Approximation} besteht dann, wenn keine \textit{c} aufeinander folgenden Faktoren selber einen Faktor bilden. 
Daraus folgt, dass in einem Faktor der LZ-Zerlegung maximal c-1 ganze Faktoren liegen können. Es kann aber sein, dass sowohl ein echtes Suffix und ein echtes Präfix der umliegenden Faktoren ebenfalls in dem Faktor der LZ-Zerlegung enthalten sind. Im ungünstigsten Fall wird damit ein Faktor vollkommen zwischen zwei Faktoren der LZ-Zerlegung aufgeteilt (vgl. Abb. \ref{flz}). 
%
\begin{figure}[h]
	\includegraphics[width=\textwidth,keepaspectratio]{faktorenmerge}
	\caption{Der Faktor $f_{LZ}$ erstreckt sich von $f_{i-1}$ bis $f_{i+c}$}
	\label{flz}
\end{figure}\\
Das bedeutet, dass wir maximal $c$-mal mehr Faktoren in der \textit{c-optimale} LZ-Approximation finden, als in der  LZ-Zerlegung.
Die Anzahl der Faktoren in der Approximation ist also durch die Anzahl der Faktoren in der LZ-Zerlegung multipliziert mit $c$ nach oben beschränkt.  
\begin{equation}
\rho = max
\left\{
\frac{c*f(s_{opt})}{f(s_{opt})},\frac{f(s_{opt})}{c * f(s_{opt})}
\right\}
\end{equation}
\begin{equation}
\rho = c
\end{equation}
Aus einer \textit{c-Optimalität} der Approximation folgt eine Güte der Approximation von $c$ \cite{LZ77Approx}.
%
%
%
\newpage
%
%
%
\section{Hashfuntionen}

Eine \emph{Hashfunktion} $h$ ist eine polstellenlose  Funktion von einem \emph{Universum U} auf eine beschränkte Teilmenge der natürlichen Zahlen $h:U \rightarrow \{0,1,2\cdots ,n \}$.
Die Eingaben bezeichnet man als Schlüssel und die Ausgaben als Hashcodes, eine Hashfunktion definiert  damit \emph{key value pairs}.
Wenn unterschiedliche Schlüssel den gleichen Hashcode besitzen, bezeichnet man dies als \emph{Kollision}.
Wenn die Menge der Eingaben größer ist als die Menge der Hashcodes, sind diese unvermeidlich.\\
Zwei Arten von Hashfunktionen  haben sich für den üblichen Gebrauch durchgesetzt, die Modulo- und die Multiplikationmethode.\\
Hashfuntionen der Modulomethode haben die Form $h(x)=x \  mod \  M$.
Hashfuntionen der Multiplikationmethode besitzen die Form $h(x)= \lfloor M * (x * A \ mod 1) \rfloor $ mit $0<A<1$.\\
$M$ ist meist eine Primzahl um eine möglichst gleiche Verteilung der Hashcodes zu erzielen.
Eine Hashfunktion lässt sich an hand folgender zentraler Kriterien bewerten:
\begin{enum}
	\item Gleichverteilung: alle Hashcodes sollen mit möglich gleicher Wahrscheinlichkeit getroffen werden
	\item Deterministisch: immer gleiche ergebinnie
\end{enum}
	
\section{Fingerprint und rolling Hash}

Ein \emph{Fingerprint} ist der Hashcode der einem String zugeordnet wird.
Fingerprints erlauben es Strings schneller zu vergleichen. 
Um herauszufinden ob zwei Strings $s_{1},s_{2}$ gleich sind müssen wir alle Symbole miteinander vergleichen.
Sollten die beiden Strings sich nur im letzten Symbol unterscheiden so haben wir alle vorherigen Symbole umsonst überprüft.
Vergleichen wir aber vorher beide Fingerprints können wir nicht gleiche Strings direkt erkennen, dies ist wesentlich effizienter da Fingerprints meist deutlich kürzer sind als die Strings selber.
Es kann aber sein, dass durch eine Kollision unterschiedliche Strings den gleichen Fingerprint besitzen.
Daher nicht aus nur die Fingerprints zu vergleichen um zusagen das zwei Strings gleich sind.
Wenn die Fingerprints gleich sind müssen danach alle Symbole des Strings untersucht werden.




Eine Hashtabelle ist eine Liste, in der jeder Hashcode einem Index entspricht.
Die zugehörige Datenstruktur ist die \emph{Hashtabelle}.
